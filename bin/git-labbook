#!/usr/bin/perl
# License: GPL v2 or later

# ABSTRACT: manage a laboratory book with Git

package git::labbook;

package main;
use warnings;
use strict;

BEGIN {
    # VERSION: generated by DZP::OurPkgVersion
}
our $VERSION //= 'not set';

use lib (split(/:/, $ENV{GITPERLLIB} // ""));

use vars qw/  $sha1 $sha1_short
              $_repository
              $_q/;

use File::Basename qw/dirname basename/;
use File::Path qw/mkpath/;
use File::Spec;
use File::Copy;
use Getopt::Long qw/:config gnu_getopt no_ignore_case auto_abbrev/;
use Memoize;
use TryCatch;
use Path::Class;
use Git::LabBook;
use Git::LabBook::Cmds;

use Git::SVN::Utils qw(
        fatal
        can_compress
        canonicalize_path
        canonicalize_url
        join_paths
        add_path_to_url
        join_paths
);

use Git qw(
        git_cmd_try
        command
        command_oneline
        command_noisy
        command_output_pipe
        command_close_pipe
        command_bidi_pipe
        command_close_bidi_pipe
);

BEGIN {
        Memoize::memoize 'Git::config';
        Memoize::memoize 'Git::config_bool';
}

# From which subdir have we been invoked?
my $cmd_dir_prefix = eval {
        command_oneline([qw/rev-parse --show-prefix/], STDERR => 0)
} || '';

print STDERR "RUNNIG: '", join("' '", "git-labbook", @ARGV), "'\n";

#$sha1 = qr/[a-f\d]{40}/;
#$sha1_short = qr/[a-f\d]{4,40}/;

#my ($_stdin, $_help, $_edit,
#    $_message, $_file, $_branch_dest,
#    $_template, $_shared,
#    $_version, $_fetch_all, $_no_rebase, $_fetch_parent,
#    $_before, $_after,
#    $_merge, $_strategy, $_preserve_merges, $_dry_run, $_parents, $_local,
#    $_prefix, $_no_checkout, $_url, $_verbose,
#    $_commit_url, $_tag, $_merge_info, $_interactive, $_set_svn_props);
my ($_help, $_version);

$_q ||= 0;

my %options = (
    'all' => {
	'labbook-file-name' => {
	    'getopt' => 's',
	    'config' => 'labbookfile',
	    'desc' => 'name of the labbook file',
	},
	'data-branch-name' => {
	    'getopt' => 's',
	    'config' => 'databranch',
	    'desc' => 'branch name for the data branch',
	},
	'data-dir-name' => {
	    'getopt' => 's',
	    'config' => 'datadir',
	    'desc' => 'directory with experiment results',
	},
	'analysis-dir-name' => {
	    'getopt' => 's',
	    'config' => 'analysisdir',
	    'desc' => 'directory with analysis material', 
	},
    },
    'init' => {
    },
    'xp-clone' => {
	'master-branch-name' => {
	    'getopt' => 's',
	    'salias' => 'b',
	    'aliases' => ['branch'],
	    'config' => 'srcbranch',
	    'desc' => 'branch to clone',
	},
    },
    'xp-start' => {
	'xp-branch-name' => {
	    'getopt' => 's',
	    'salias' => 'b',
	    'aliases' => ['branch'],
	    'config' => 'xpbranch',
	    'desc' => 'branch name template for experiments',
	},
	'labbook-entry' => {
	    'getopt' => '!',
	    'config' => 'labbookentry',
	    'desc' => 'add an entry in the labbook',
	},
    },
    'xp-finish' => {
	'xp-tag-name' => {
	    'getopt' => 's',
	    'salias' => 't',
	    'aliases' => ['tag'],
	    'config' => 'xptag',
	    'desc' => 'tag name template for experiments',
	},
    },
);    

my $cmds = new Git::LabBook::Cmds(
    'options' => \%options,
    );

$cmds->register(
    'name' => 'help',
    'code' => sub {},
    'desc' => "Get a quick help on commands",
    )->register(
    'name' => 'init',
    'code' => \&cmd_init,
    'desc' => "Initialize a repo for labbook usage",
    )->register(
    'name' => 'xp',
    'has-subcmds' => 1,
    'desc' => "manage an experiment (requires subcommand)",
    )->register(
    'name' => 'clone',    
    'code' => \&cmd_clone,
    'desc' => "clone only one branch of a repo",
    )->register(
    'main-cmd' => 'xp',
    'name' => 'start',    
    'code' => \&cmd_xp_start,
    'desc' => "start a new experiment (requires a name)",
    )->register(
    'main-cmd' => 'xp',
    'name' => 'finish',    
    'code' => \&cmd_xp_finish,
    'desc' => "close the current experiment",
    )->register(
    'main-cmd' => 'xp',
    'name' => 'push',
    'code' => \&cmd_xp_push,
    'desc' => "push the current experiment branch",
    )->register(
    'name' => '_merge',
    'code' => \&cmd__merge,
    'desc' => "Internal merge driver for git-labbook specific files",
    )->register(
    'name' => '_clone',
    'code' => \&cmd__clone,
    'desc' => "Internal clone suboperation",
    );

my $labbook = new Git::LabBook();

package FakeTerm;  
sub new {          
        my ($class, $reason) = @_;
        return bless \$reason, shift;
}                       
sub readline {
        my $self = shift;    
        die "Cannot use readline on FakeTerm: $$self";
}                            
package main;

my $term;             
sub term_init {
        $term = eval { 
                require Term::ReadLine; 
                $ENV{"GIT_LABBOOK_NOTTY"}
                        ? new Term::ReadLine 'git-labbook', \*STDIN, \*STDOUT
                        : new Term::ReadLine 'git-labbook';
        };
        if ($@) {
                $term = new FakeTerm "$@: going non-interactive";
        }
}

$cmds->parse(@ARGV);

my $cmd;

if ($cmds->cmd_parsed && $cmds->cmd->fullname eq 'help') {
    $cmds->parse($cmds->ARGV);
    if ($cmds->cmd_parsed('all' => 1)) {
	$cmd=$cmds->cmd;
    }
    usage(0);
}

# fake while, just to be able to call 'last'
while ($cmds->cmd_parsed) {
    $cmd=$cmds->cmd;
    last if $cmd->fullname =~ /clone/;

    init_repo('.');
    last;
}

parse_opts();

usage(0) if $_help;
version() if $_version;
usage(1) unless defined $cmd;
usage(1) unless !$cmd->has_subcmds;

#Git::SVN::init_vars();
eval {
    #Git::SVN::verify_remotes_sanity();
    $cmd->run(@ARGV);
    #post_fetch_checkout();
};
fatal $@ if $@;
exit 0;

####################### primary functions ######################
sub usage {
    my $exit = shift || 0;
    my $fd = $exit ? \*STDERR : \*STDOUT;
    print $fd <<"";
git-labbook - manage a labbook with git
usage: git labbook <command> [subcommand] [options] [arguments]\n


    my $print_opts = sub {
	my $grp = shift;
	my $head = shift;
	my $opts = $cmds->opts($labbook, $grp);
	print $fd "  $head\n" if defined($head) && scalar(@{$opts});
	foreach my $opt (@{$opts}) {
	    my $t = $opt->{'getopt'};
	    my $x = $t eq 's' ? '<arg>' : $t eq 'i' ? '<num>' : '';
	    printf $fd "% 4s %-30s%s (default: %s)\n", ' ', join(', ', @{$opt->{'names'}}).
	    " $x ", $opt->{'desc'}, $opt->{'default'}; 
	}
    };

    if ($cmd) {
	print $fd '  ',pack('A17',$cmd->displayname),$cmd->desc,"\n   options:\n";
	$print_opts->();
	if ($cmd->does('parent')) {
	    $print_opts->($cmd->parent->fullname);
	}
	$print_opts->($cmd->fullname);
	exit $exit;
    }

    print $fd "  Common options:\n";
    $print_opts->();
    print $fd "Available commands:\n";
    
    foreach (sort { $a->fullname cmp $b->fullname } $cmds->all_cmds) {
	# do not display internal commands
	next if $_->name =~ /^_/;
	#next if $_->has_subcmds && !defined($cmd);
	print $fd '  ',pack('A17',$_->displayname),$_->desc,"\n";
	#foreach (sort keys %{$_->opts}) {
	#    # mixed-case options are for .git/config only
	#    next if /[A-Z]/ && /^[a-z]+$/i;
	#    # prints out arguments as they should be passed:
	#    my $x = s#[:=]s$## ? '<arg>' : s#[:=]i$## ? '<num>' : '';
	#    print $fd ' ' x 21, join(', ', map { length $_ > 1 ?
	#					     "--$_" : "-$_" }
	#			     split /\|/,$_)," $x\n";
	#}
	$print_opts->($_->fullname, " options:");
    }
    exit $exit;
}

sub version {
    print "git-labbook version $VERSION\n";
    exit 0;
}

sub setup_repo {
    try {
	$_repository->command(qw/config --get-regexp '^merge\.gitlabbookmerge\.'/);
    } catch (Git::Error::Command $e) {
	print STDERR "I: setting up labbook merge driver ($e)\n";
	$_repository->command_noisy(qw/config --local --replace-all merge.gitlabbookmerge.name/, "Git LabBook specific merge driver");
	$_repository->command_noisy(qw/config --local --replace-all merge.gitlabbookmerge.driver/, "git-labbook _merge -- %O %A %B %P");
    }
}

sub cmd_init {
    ensure_clean("Cannot initialize a LabBook with a dirty index");
    my $srcdir=$labbook->srcdir;
    my $datadir=$labbook->datadir;
    my $analysisdir=$labbook->analysisdir;
    $srcdir->mkpath;
    $datadir->mkpath;
    $analysisdir->mkpath;
    my $labbookfile=$labbook->labbookfile;
    {
	setup_repo;
	my $fh=file('.gitattributes')->opena;
	print $fh "/", $labbook->labbookstate, " merge=gitlabbookmerge\n";
	print $fh "/", $labbookfile, " merge=gitlabbookmerge\n";
	$fh->close();
	$_repository->command_noisy(qw/add .gitattributes /);
	
	$_repository->command_noisy(qw/commit -m/, "labbook setup");
    }
    if (! $labbookfile->stat()) {
	my $fh=$labbookfile->openw;
	print $fh "* Documentation\n";
	print $fh "* Experiments\n";
	$fh->close();
	$_repository->command_noisy(qw/add/, $labbookfile);
	$_repository->command_noisy(qw/commit -m/, "labbook initialized");

    }
    my $cur_ref = $_repository->command_oneline('symbolic-ref', 'HEAD');
    $_repository->command_noisy('checkout', '-b', $labbook->databranch);
    my $labbookstate=$labbook->labbookstate;
    $_repository->command_noisy(qw/config -f/, $labbookstate, qw/--replace-all labbook-state.state data/);
    $_repository->command_noisy(qw/add/, $labbookstate);
    $_repository->command_noisy(qw/commit -m/, "Data branch started");
    $_repository->command_noisy(qw/symbolic-ref -m/, "labbook: switch back to previous point", 'HEAD', $cur_ref);
    $_repository->command_noisy(qw/reset --hard HEAD/);
}

use Data::Dumper;
sub cmd_clone {
    my $cmd = shift;

    print STDERR "I: cloning only the ", $labbook->srcbranch, " branch\n";
    my $dir;
    my @args=@_;
    $ENV{'_GITLABBOOK_CMD'}='xp-clone';
    my ($fh, $c) = command_output_pipe(qw/labbook _clone --single-branch -b/, $labbook->srcbranch, @args);
    while(defined(my $line=<$fh>)) {
	chomp($line);
	if ($line =~ /Cloning into (bare repository )?'(?<dir>.*)'\.\.\.$/) {
	    $dir=$+{'dir'};
	    #print "F ($dir): $line\n";
	    last;
	}
	#print "S: $line\n";
    }
    while(defined(my $line=<$fh>)) {
	#print $line;
    }
    command_close_pipe($fh, $c);
    if (not defined($dir)) {
	fatal "Cannot find the cloned directory";
    }
    init_repo($dir);
    setup_repo;
}

sub cmd__clone {
    my $cmd = shift;
    shift; # consume the '_clone' cmd as args are not parsed.
    
    my $lc_all=$ENV{'LC_ALL'};
    if ( ($ENV{'_GITLABBOOK_CMD'} // '') ne 'xp-clone') {
	fatal "E: git-labbook _merge operation invocked out of git-labbook standard operation context";
    }
    print STDERR "I: really cloning '".join("' '", @_)."'\n";
    open(STDERR, ">&STDOUT");
    $ENV{'LC_ALL'}='C';
    my $dir;
    command_noisy(qw/clone/, @_);
}

sub cmd_xp_start {
    my $cmd = shift;
    my $name = shift;

    if (not defined($name)) {
	usage(1);
    }

    ensure_clean("Cannot start a new experiment with a dirty index");
    my $xpbranch=$labbook->xpbranch($name);
    $_repository->command_noisy('checkout', '-b', $xpbranch);
    my $datadir=dir($labbook->datadir, $name);
    $datadir->mkpath;
    if ($labbook->labbookentry) {
	my $labbookfile = $labbook->labbookfile;
	my $fh=$labbookfile->opena;
	print $fh "** $name\n";
	$fh->close();
	$_repository->command_noisy(qw/add/, $labbookfile);
    }
    my $labbookstate=$labbook->labbookstate;
    my $sha1=$_repository->command_oneline(qw/rev-parse HEAD/);
    $_repository->command_noisy(qw/config -f/, $labbookstate, qw/--replace-all labbook-state.state xp/);
    $_repository->command_noisy(qw/config -f/, $labbookstate, qw/--replace-all labbook-state.xp/, $name);
    $_repository->command_noisy(qw/config -f/, $labbookstate, qw/--replace-all labbook-state.xp-start/, $sha1);
    $_repository->command_noisy(qw/add/, $labbookstate);
    $_repository->command_noisy(qw/commit -m/, "Experiment $name started");
}

sub cmd_xp_finish {
    my $cmd = shift;

    my $labbookstate=$labbook->labbookstate;

    my $info = get_state(
	'require' => {
	    'state' => 'xp',
	},
	'want' => [
	    'xp',
	],
	);
    my ($state,$name)=('xp', $info->{'xp'});

    if (!defined($name) || $name eq '') {
	fatal "E: The current experiment has no registered name";
    }

    my $xptag=$labbook->xptag($name);
    $_repository->command_noisy('tag', $xptag);

    my $cur_ref = $_repository->command_oneline('symbolic-ref', 'HEAD');
    my $short_cur_ref = $_repository->command_oneline('symbolic-ref', '--short', 'HEAD');

    $ENV{'_GITLABBOOK_CMD'}='xp-finish';
    $ENV{'_GITLABBOOK_XP_NAME'}=$_repository->command_oneline(qw/config -f/, $labbookstate, qw/labbook-state.xp/);
    $ENV{'_GITLABBOOK_XP_START'}=$_repository->command_oneline(qw/config -f/, $labbookstate, qw/labbook-state.xp-start/);
    $ENV{'_GITLABBOOK_XP_END'}=$_repository->command_oneline(qw/rev-parse HEAD/);
    $_repository->command_noisy('checkout', $labbook->databranch);
    $_repository->command_noisy(qw/merge -s recursive -m/, "Merging with $short_cur_ref branch", $short_cur_ref);
    delete($ENV{'_GITLABBOOK_STATE'});
}

sub cmd_xp_push {
    my $cmd = shift;

    my $labbookstate=$labbook->labbookstate;

    my $info = get_state(
	'require' => {
	    'state' => 'xp',
	},
	'want' => [
	    'xp',
	],
	);
    my ($state,$name)=('xp', $info->{'xp'});

    if (!defined($name) || $name eq '') {
	fatal "E: The current experiment has no registered name";
    }

    my $xptag=$labbook->xptag($name);
    my $cur_ref = $_repository->command_oneline('symbolic-ref', '--short', 'HEAD');
    print STDERR "I: git '", join("' '",qw/push -u/, shift // 'origin', $cur_ref), "'\n";
    $_repository->command_noisy(qw/push -u/, shift // 'origin', $cur_ref);
}

sub cmd__merge {
    my $cmd = shift;
    my $fancestor = shift;
    my $fcurrent = shift;
    my $fother = shift;
    my $path = shift;

    if ( ($ENV{'_GITLABBOOK_CMD'} // '') ne 'xp-finish') {
	fatal "E: git-labbook _merge operation invocked out of git-labbook standard operation context";
    }
    
    if ($path eq $labbook->labbookstate) {
	copy($fcurrent, $fancestor) or die "Copy failed: $!";
	return;
    }
    if ($path eq $labbook->labbookfile) {
	my ($pipe, $ctx)=$_repository->command_output_pipe('diff', $ENV{'_GITLABBOOK_XP_START'}.'..'.$ENV{'_GITLABBOOK_XP_END'},
					     '--', $labbook->labbookfile);
	my @diffs=<$pipe>;
	$_repository->command_close_pipe($pipe, $ctx);
	my @diffxp;
	while (defined(my $line = shift @diffs)) {
	    last if ($line =~ /^@@/);
	}
	while (defined(my $line = shift @diffs)) {
	    if ($line =~ /^[+][*][*] $ENV{'_GITLABBOOK_XP_NAME'}/) {
		push @diffxp, substr($line, 1);
		last;
	    }
	}
	while (defined(my $line = shift @diffs)) {
	    if ($line !~ /^[+]/ && $line !~ /^\s$/) {
		@diffxp=();
		last
	    }
	    push @diffxp, substr($line, 1);
	}
	if (scalar(@diffxp) == 0) {
	    print STDERR "I: xp results are not just added at the end of the labbook. Trying merge with org-merge-driver.\n";

	    my $res = system("org-merge-driver", $fancestor, $fcurrent, $fother, "tmpfile") == 0;
	    move("tmpfile", $fcurrent);
	    if (!$res) {
		fatal "E: still conflicts to resolve into $path";
	    }
	    return;
	} else {
	    print STDERR "I: adding xp results in the data labbook.\n";
	    my $fh=file($fcurrent)->opena();
	    print $fh @diffxp;
	    $fh->close;
	}
	return;
    }
    fatal "E: git-labbook internal driver cannot be invocked on '$path' file";
}

########################### utility functions #########################

sub init_repo {
    my $dir = shift;
    chdir $dir || fatal "E: cannot enter directory '$dir'";
    
    my ($git_dir, $cdup);
    git_cmd_try {
	$git_dir = command_oneline([qw/rev-parse --git-dir/]);
    } "Unable to find .git directory\n";
    git_cmd_try {
	$cdup = command_oneline(qw/rev-parse --show-cdup/);
	chomp $cdup if ($cdup);
	$cdup = "." unless ($cdup && length $cdup);
    } "Already at toplevel, but $git_dir not found\n";
    $ENV{GIT_DIR} = $git_dir;
    chdir $cdup or die "Unable to chdir up to '$cdup'\n";
    $_repository = Git->repository(Repository => $ENV{GIT_DIR});
}

sub parse_opts {
    my %opts=();
    %opts = %{$cmd->opts($labbook)} if (defined $cmd);
    return if ($cmd && ($cmd->fullname =~ '_clone'));

    read_git_config(\%opts);
    if ($cmd && ($cmd->fullname =~ 'clone')) {
        Getopt::Long::Configure('pass_through');
    }
    @ARGV=$cmds->ARGV;
    my $rv = GetOptions(%opts, 'help|H' => \$_help, 'version|V' => \$_version);
    exit 1 if (!$rv && $cmd);
}
    
use Data::Dumper;
# convert GetOpt::Long specs for use by git-config
sub read_git_config {
    my $opts = shift;
    my @config_only;
    #print "opts=", Dumper($opts), "\n";
    chomp(my $bare = `git config --bool --get core.bare`);
    my $labbookconfig="--file .gitlabbook";
    if ($bare eq 'true') {
	$labbookconfig="--blob HEAD:.gitlabbook";
    }
    foreach my $o (keys %$opts) {
	# if we have mixedCase and a long option-only, then
	# it's a config-only variable that we don't need for
	# the command-line.
	push @config_only, $o if ($o =~ /[A-Z]/ && $o =~ /^[a-z]+$/i);
	my $v = $opts->{$o};
	my ($key) = ($o =~ /^([a-zA-Z\-]+)/);
	#$key =~ s/-//g;
	my $arg = 'git config';
	$arg .= ' --int' if ($o =~ /[:=]i$/);
	$arg .= ' --bool' if ($o !~ /[:=][sfi]$/);
	#print "v1=", Dumper($v), "\n";
	if (ref $v eq 'ARRAY') {
	    chomp(my @tmp = `$arg --get-all labbook.$key`);
	    @$v = @tmp if @tmp;
	} else {
	    chomp(my $tmp = `$arg --get labbook.$key`);
	    if (!$tmp) {
		chomp($tmp = `$arg $labbookconfig --get labbook.$key`);
	    }
	    #print "tmp=", Dumper($tmp), "\n";
	    if ($tmp && !($arg =~ / --bool/ && $tmp eq 'false')) {
		$v->($key, $tmp);
	    }
	}
	#print "v2=", Dumper($v), "\n";
    }
    delete @$opts{@config_only} if @config_only;
    #print "opts=", Dumper($opts), "\n";
}

sub get_state {
    my %p = @_;
    my %res;

    my $labbookstate=$labbook->labbookstate;

    if (exists($p{'require'})) {
	foreach my $key (keys %{$p{'require'}}) {
	    my $rval;
	    eval {
		$rval = $_repository->command_oneline(qw/config -f/, $labbookstate, 'labbook-state.'.$key);
	    };
	    if (!defined($rval)) {
		fatal "E: labbook-state: cannot find the '$key' key";
	    }
	    if ($rval ne $p{'require'}->{$key}) {
		fatal "E: labbook-state: invalid value '$rval' for key '$key' (expected: '"
		    .$p{'require'}->{$key}."'";
	    }
	    $res{$key}=$rval;
	}
    }
    if (exists($p{'want'})) {
	foreach my $key (@{$p{'want'}}) {
	    my $rval;
	    eval {
		$rval = $_repository->command_oneline(qw/config -f/, $labbookstate, 'labbook-state.'.$key);
	    };
	    if (!defined($rval)) {
		fatal "E: labbook-state: cannot find the '$key' key";
	    }
	    $res{$key}=$rval;
	}
    }
    if (exists($p{'wish'})) {
	foreach my $key (@{$p{'wish'}}) {
	    my $rval;
	    eval {
		$rval = $_repository->command_oneline(qw/config -f/, $labbookstate, 'labbook-state.'.$key);
	    };
	    $res{$key}=$rval;
	}
    }
    return \%res;
}

sub ensure_clean {
    my $msg = shift;
    
    $_repository->command_noisy(qw/update-index --refresh/);
    git_cmd_try { $_repository->command_oneline(qw/diff-index --quiet HEAD --/) }
    $msg."\nCommit your changes first, "
	. "or stash them with `git stash'.\n";
}
    
