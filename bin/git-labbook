#!/usr/bin/perl
# License: GPL v2 or later

# ABSTRACT: manage a laboratory book with Git

package git::labbook;

package main;
use warnings;
use strict;

BEGIN {
    # VERSION: generated by DZP::OurPkgVersion
}
our $VERSION //= 'not set';

use lib (split(/:/, $ENV{GITPERLLIB} // ""));

use vars qw/  $sha1 $sha1_short
              $_repository
              $_q/;

use File::Basename qw/dirname basename/;
use File::Path qw/mkpath/;
use File::Spec;
use Getopt::Long qw/:config gnu_getopt no_ignore_case auto_abbrev/;
use Memoize;
use Path::Class;
use Git::LabBook;
use Git::LabBook::Cmds;

use Git::SVN::Utils qw(
        fatal
        can_compress
        canonicalize_path
        canonicalize_url
        join_paths
        add_path_to_url
        join_paths
);

use Git qw(
        git_cmd_try
        command
        command_oneline
        command_noisy
        command_output_pipe
        command_close_pipe
        command_bidi_pipe
        command_close_bidi_pipe
);

BEGIN {
        Memoize::memoize 'Git::config';
        Memoize::memoize 'Git::config_bool';
}

# From which subdir have we been invoked?
my $cmd_dir_prefix = eval {
        command_oneline([qw/rev-parse --show-prefix/], STDERR => 0)
} || '';

#$sha1 = qr/[a-f\d]{40}/;
#$sha1_short = qr/[a-f\d]{4,40}/;

#my ($_stdin, $_help, $_edit,
#    $_message, $_file, $_branch_dest,
#    $_template, $_shared,
#    $_version, $_fetch_all, $_no_rebase, $_fetch_parent,
#    $_before, $_after,
#    $_merge, $_strategy, $_preserve_merges, $_dry_run, $_parents, $_local,
#    $_prefix, $_no_checkout, $_url, $_verbose,
#    $_commit_url, $_tag, $_merge_info, $_interactive, $_set_svn_props);
my ($_help, $_version);

$_q ||= 0;

my %options = (
    'all' => {
	'labbook-file-name' => {
	    'getopt' => 's',
	    'config' => 'labbookfile',
	    'desc' => 'name of the labbook file',
	},
	'data-branch-name' => {
	    'getopt' => 's',
	    'config' => 'databranch',
	    'desc' => 'branch name for the data branch',
	},
	'data-dir-name' => {
	    'getopt' => 's',
	    'config' => 'datadir',
	    'desc' => 'directory with experiment results',
	},
	'analysis-dir-name' => {
	    'getopt' => 's',
	    'config' => 'analysisdir',
	    'desc' => 'directory with analysis material', 
	},
    },
    'init' => {
    },
    'xp-start' => {
	'xp-branch-name' => {
	    'getopt' => 's',
	    'salias' => 'b',
	    'aliases' => ['branch'],
	    'config' => 'xpbranch',
	    'desc' => 'branch name template for experiments',
	},
	'labbook-entry' => {
	    'getopt' => '!',
	    'config' => 'labbookentry',
	    'desc' => 'add an entry in the labbook',
	},
    },
    'xp-finish' => {
	'xp-tag-name' => {
	    'getopt' => 's',
	    'salias' => 't',
	    'aliases' => ['tag'],
	    'config' => 'xptag',
	    'desc' => 'tag name template for experiments',
	},
    },
);    

my $cmds = new Git::LabBook::Cmds(
    'options' => \%options,
    );

$cmds->register(
    'name' => 'help',
    'code' => sub {},
    'desc' => "Get a quick help on commands",
    )->register(
    'name' => 'init',
    'code' => \&cmd_init,
    'desc' => "Initialize a repo for labbook usage",
    )->register(
    'name' => 'xp',
    'has-subcmds' => 1,
    'desc' => "manage an experiment (requires subcommand)",
    )->register(
    'main-cmd' => 'xp',
    'name' => 'start',    
    'code' => \&cmd_xp_start,
    'desc' => "start a new experiment (requires a name)",
    )->register(
    'main-cmd' => 'xp',
    'name' => 'finish',    
    'code' => \&cmd_xp_finish,
    'desc' => "close the current experiment",
    );

my $labbook = new Git::LabBook();

package FakeTerm;  
sub new {          
        my ($class, $reason) = @_;
        return bless \$reason, shift;
}                       
sub readline {
        my $self = shift;    
        die "Cannot use readline on FakeTerm: $$self";
}                            
package main;

my $term;             
sub term_init {
        $term = eval { 
                require Term::ReadLine; 
                $ENV{"GIT_LABBOOK_NOTTY"}
                        ? new Term::ReadLine 'git-labbook', \*STDIN, \*STDOUT
                        : new Term::ReadLine 'git-labbook';
        };
        if ($@) {
                $term = new FakeTerm "$@: going non-interactive";
        }
}

$cmds->parse(@ARGV);

my $cmd;

if ($cmds->cmd_parsed && $cmds->cmd->fullname eq 'help') {
    $cmds->parse($cmds->ARGV);
    if ($cmds->cmd_parsed('all' => 1)) {
	$cmd=$cmds->cmd;
    }
    usage(0);
}

if ($cmds->cmd_parsed) {
    $cmd=$cmds->cmd;

    my ($git_dir, $cdup);
    git_cmd_try {
	$git_dir = command_oneline([qw/rev-parse --git-dir/]);
    } "Unable to find .git directory\n";
    git_cmd_try {
	$cdup = command_oneline(qw/rev-parse --show-cdup/);
	chomp $cdup if ($cdup);
	$cdup = "." unless ($cdup && length $cdup);
    } "Already at toplevel, but $git_dir not found\n";
    $ENV{GIT_DIR} = $git_dir;
    chdir $cdup or die "Unable to chdir up to '$cdup'\n";
    $_repository = Git->repository(Repository => $ENV{GIT_DIR});
}

my %opts=();
%opts = %{$cmd->opts($labbook)} if (defined $cmd);

read_git_config(\%opts);
#if ($cmd && ($cmd eq 'log' || $cmd eq 'blame')) {
#        Getopt::Long::Configure('pass_through');
#}
@ARGV=$cmds->ARGV;
my $rv = GetOptions(%opts, 'help|H' => \$_help, 'version|V' => \$_version);
exit 1 if (!$rv && $cmd);

usage(0) if $_help;
version() if $_version;
usage(1) unless defined $cmd;
usage(1) unless !$cmd->has_subcmds;

#Git::SVN::init_vars();
eval {
    #Git::SVN::verify_remotes_sanity();
    $cmd->run(@ARGV);
    #post_fetch_checkout();
};
fatal $@ if $@;
exit 0;

####################### primary functions ######################
sub usage {
    my $exit = shift || 0;
    my $fd = $exit ? \*STDERR : \*STDOUT;
    print $fd <<"";
git-labbook - manage a labbook with git
usage: git labbook <command> [subcommand] [options] [arguments]\n


    my $print_opts = sub {
	my $grp = shift;
	my $head = shift;
	my $opts = $cmds->opts($labbook, $grp);
	print $fd "  $head\n" if defined($head) && scalar(@{$opts});
	foreach my $opt (@{$opts}) {
	    my $t = $opt->{'getopt'};
	    my $x = $t eq 's' ? '<arg>' : $t eq 'i' ? '<num>' : '';
	    printf $fd "% 4s %-30s%s (default: %s)\n", ' ', join(', ', @{$opt->{'names'}}).
	    " $x ", $opt->{'desc'}, $opt->{'default'}; 
	}
    };

    if ($cmd) {
	print $fd '  ',pack('A17',$cmd->displayname),$cmd->desc,"\n   options:\n";
	$print_opts->();
	if ($cmd->does('parent')) {
	    $print_opts->($cmd->parent->fullname);
	}
	$print_opts->($cmd->fullname);
	exit $exit;
    }

    print $fd "  Common options:\n";
    $print_opts->();
    print $fd "Available commands:\n";
    
    foreach (sort { $a->fullname cmp $b->fullname } $cmds->all_cmds) {
	#next if $_->has_subcmds && !defined($cmd);
	print $fd '  ',pack('A17',$_->displayname),$_->desc,"\n";
	#foreach (sort keys %{$_->opts}) {
	#    # mixed-case options are for .git/config only
	#    next if /[A-Z]/ && /^[a-z]+$/i;
	#    # prints out arguments as they should be passed:
	#    my $x = s#[:=]s$## ? '<arg>' : s#[:=]i$## ? '<num>' : '';
	#    print $fd ' ' x 21, join(', ', map { length $_ > 1 ?
	#					     "--$_" : "-$_" }
	#			     split /\|/,$_)," $x\n";
	#}
	$print_opts->($_->fullname, " options:");
    }
    exit $exit;
}

sub version {
        print "git-labbook version $VERSION\n";
        exit 0;
}

sub cmd_init {
    ensure_clean("Cannot initialize a LabBook with a dirty index");
    my $srcdir=$labbook->srcdir;
    my $datadir=$labbook->datadir;
    my $analysisdir=$labbook->analysisdir;
    $srcdir->mkpath;
    $datadir->mkpath;
    $analysisdir->mkpath;
    my $labbookfile=$labbook->labbookfile;
    if (! $labbookfile->stat()) {
	my $fh=$labbookfile->openw;
	print $fh "* Documentation\n";
	print $fh "* Experiments\n";
	$fh->close();
	command_noisy(qw/add/, $labbookfile);
	command_noisy(qw/commit -m/, "labbook initialized");
    }
    my $cur_ref = command_oneline('symbolic-ref', 'HEAD');
    command_noisy('checkout', '-b', $labbook->databranch);
    my $labbookstate=$labbook->labbookstate;
    command_noisy(qw/config -f/, $labbookstate, qw/--replace-all labbook-state.state data/);
    command_noisy(qw/add/, $labbookstate);
    command_noisy(qw/commit -m/, "Data branch started");
    command_noisy(qw/symbolic-ref -m/, "labbook: switch back to previous point", 'HEAD', $cur_ref);
    command_noisy(qw/reset --hard HEAD/);
}

sub cmd_xp_start {
    my $cmd = shift;
    my $name = shift;

    if (not defined($name)) {
	usage(1);
    }

    ensure_clean("Cannot start a new experiment with a dirty index");
    my $xpbranch=$labbook->xpbranch($name);
    command_noisy('checkout', '-b', $xpbranch);
    my $datadir=dir($labbook->datadir, $name);
    $datadir->mkpath;
    if ($labbook->labbookentry) {
	my $labbookfile = $labbook->labbookfile;
	my $fh=$labbookfile->opena;
	print $fh "** $name\n";
	$fh->close();
	command_noisy(qw/add/, $labbookfile);
    }
    my $labbookstate=$labbook->labbookstate;
    command_noisy(qw/config -f/, $labbookstate, qw/--replace-all labbook-state.state xp/);
    command_noisy(qw/config -f/, $labbookstate, qw/--replace-all labbook-state.xp/, $name);
    command_noisy(qw/add/, $labbookstate);
    command_noisy(qw/commit -m/, "Experiment $name started");
}

sub cmd_xp_finish {
    my $cmd = shift;

    my $labbookstate=$labbook->labbookstate;

    my ($state,$name);
    eval {
	$state = command_oneline(qw/config -f/, $labbookstate, qw/labbook-state.state/);
	$name = command_oneline(qw/config -f/, $labbookstate, qw/labbook-state.xp/);
    };
    if (!defined($state)) {
	fatal "E: You are not in an experiment (no state)";
    }
    if ($state ne 'xp') {
	fatal "E: You are not in an experiment (current state: $state)";
    }
    if (!defined($name) || $name eq '') {
	fatal "E: The current experiment has no registered name";
    }

    my $xptag=$labbook->xptag($name);
    command_noisy('tag', $xptag);

    my $cur_ref = command_oneline('symbolic-ref', 'HEAD');
    my $short_cur_ref = command_oneline('symbolic-ref', '--short', 'HEAD');
    command_noisy('checkout', $labbook->databranch);
    command_noisy(qw/merge -s recursive -Xours -m/, "Merging with $short_cur_ref branch", $short_cur_ref);
}

########################### utility functions #########################

use Data::Dumper;
# convert GetOpt::Long specs for use by git-config
sub read_git_config {
    my $opts = shift;
    my @config_only;
    #print "opts=", Dumper($opts), "\n";
    chomp(my $bare = `git config --bool --get core.bare`);
    my $labbookconfig="--file .gitlabbook";
    if ($bare eq 'true') {
	$labbookconfig="--blob HEAD:.gitlabbook";
    }
    foreach my $o (keys %$opts) {
	# if we have mixedCase and a long option-only, then
	# it's a config-only variable that we don't need for
	# the command-line.
	push @config_only, $o if ($o =~ /[A-Z]/ && $o =~ /^[a-z]+$/i);
	my $v = $opts->{$o};
	my ($key) = ($o =~ /^([a-zA-Z\-]+)/);
	#$key =~ s/-//g;
	my $arg = 'git config';
	$arg .= ' --int' if ($o =~ /[:=]i$/);
	$arg .= ' --bool' if ($o !~ /[:=][sfi]$/);
	#print "v1=", Dumper($v), "\n";
	if (ref $v eq 'ARRAY') {
	    chomp(my @tmp = `$arg --get-all labbook.$key`);
	    @$v = @tmp if @tmp;
	} else {
	    chomp(my $tmp = `$arg --get labbook.$key`);
	    if (!$tmp) {
		chomp($tmp = `$arg $labbookconfig --get labbook.$key`);
	    }
	    #print "tmp=", Dumper($tmp), "\n";
	    if ($tmp && !($arg =~ / --bool/ && $tmp eq 'false')) {
		$v->($key, $tmp);
	    }
	}
	#print "v2=", Dumper($v), "\n";
    }
    delete @$opts{@config_only} if @config_only;
    #print "opts=", Dumper($opts), "\n";
}

sub ensure_clean {
    my $msg = shift;
    
    command_noisy(qw/update-index --refresh/);
    git_cmd_try { command_oneline(qw/diff-index --quiet HEAD --/) }
    $msg."\nCommit your changes first, "
	. "or stash them with `git stash'.\n";
}
    
