#!/usr/bin/perl
# License: GPL v2 or later

# ABSTRACT: manage a laboratory book with Git

package git::labbook;

package main;
use warnings;
use strict;

BEGIN {
    # VERSION: generated by DZP::OurPkgVersion
}
our $VERSION //= 'not set';

use lib (split(/:/, $ENV{GITPERLLIB} // ""));

use vars qw/  $sha1 $sha1_short
              $_repository
              $_q/;

use File::Basename qw/dirname basename/;
use File::Path qw/mkpath/;
use File::Spec;
use Getopt::Long qw/:config gnu_getopt no_ignore_case auto_abbrev/;
use Memoize;
use Path::Class;
use Git::LabBook;
use Git::LabBook::Cmds;

use Git::SVN::Utils qw(
        fatal
        can_compress
        canonicalize_path
        canonicalize_url
        join_paths
        add_path_to_url
        join_paths
);

use Git qw(
        git_cmd_try
        command
        command_oneline
        command_noisy
        command_output_pipe
        command_close_pipe
        command_bidi_pipe
        command_close_bidi_pipe
);

BEGIN {
        Memoize::memoize 'Git::config';
        Memoize::memoize 'Git::config_bool';
}

# From which subdir have we been invoked?
my $cmd_dir_prefix = eval {
        command_oneline([qw/rev-parse --show-prefix/], STDERR => 0)
} || '';

#$sha1 = qr/[a-f\d]{40}/;
#$sha1_short = qr/[a-f\d]{4,40}/;

#my ($_stdin, $_help, $_edit,
#    $_message, $_file, $_branch_dest,
#    $_template, $_shared,
#    $_version, $_fetch_all, $_no_rebase, $_fetch_parent,
#    $_before, $_after,
#    $_merge, $_strategy, $_preserve_merges, $_dry_run, $_parents, $_local,
#    $_prefix, $_no_checkout, $_url, $_verbose,
#    $_commit_url, $_tag, $_merge_info, $_interactive, $_set_svn_props);
my ($_help, $_version);

$_q ||= 0;

my %layout_opts = (
    'labbook-file-name=s' => \&store_config,
    'data-branch-name=s' => \&store_config,
    'data-dir-name=s' => \&store_config,
    'analysis-dir-name=s' => \&store_config,
    );

my %init_opts = (
    %layout_opts,
    );

my %xp_opts = (
    %layout_opts,
    );

my %xp_start_opts = (
    %xp_opts,
    );

my $cmds = new Git::LabBook::Cmds();
my $labbook = new Git::LabBook();

$cmds->register(
    'name' => 'help',
    'code' => sub {},
    'desc' => "Get a quick help on commands",
    'opts' => \%init_opts,
    )->register(
    'name' => 'init',
    'code' => \&cmd_init,
    'desc' => "Initialize a repo for labbook usage",
    'opts' => \%init_opts,
    )->register(
    'name' => 'xp',
    'has-subcmds' => 1,
    'desc' => "manage an experiment (requires subcommand)",
    'opts' => \%xp_opts,
    )->register(
    'main-cmd' => 'xp',
    'name' => 'start',    
    'code' => \&cmd_xp_start,
    'desc' => "start a new experiment (requires a name)",
    'opts' => { %xp_opts, %xp_start_opts },
    );

sub store_config {
    my $name = shift;
    my $value = shift;

    #print STDERR "Setting $name to $value\n";
    $labbook->set($name, $value);
}

package FakeTerm;  
sub new {          
        my ($class, $reason) = @_;
        return bless \$reason, shift;
}                       
sub readline {
        my $self = shift;    
        die "Cannot use readline on FakeTerm: $$self";
}                            
package main;

my $term;             
sub term_init {
        $term = eval { 
                require Term::ReadLine; 
                $ENV{"GIT_LABBOOK_NOTTY"}
                        ? new Term::ReadLine 'git-labbook', \*STDIN, \*STDOUT
                        : new Term::ReadLine 'git-labbook';
        };
        if ($@) {
                $term = new FakeTerm "$@: going non-interactive";
        }
}

$cmds->parse(@ARGV);

my $cmd;

if ($cmds->cmd_parsed && $cmds->cmd->fullname eq 'help') {
    $cmds->parse($cmds->ARGV);
    if ($cmds->cmd_parsed('all' => 1)) {
	$cmd=$cmds->cmd;
    }
    usage(0);
}

if ($cmds->cmd_parsed) {
    $cmd=$cmds->cmd;

    my ($git_dir, $cdup);
    git_cmd_try {
	$git_dir = command_oneline([qw/rev-parse --git-dir/]);
    } "Unable to find .git directory\n";
    git_cmd_try {
	$cdup = command_oneline(qw/rev-parse --show-cdup/);
	chomp $cdup if ($cdup);
	$cdup = "." unless ($cdup && length $cdup);
    } "Already at toplevel, but $git_dir not found\n";
    $ENV{GIT_DIR} = $git_dir;
    chdir $cdup or die "Unable to chdir up to '$cdup'\n";
    $_repository = Git->repository(Repository => $ENV{GIT_DIR});
}

my %opts=();
%opts = %{$cmd->opts} if (defined $cmd);

read_git_config(\%opts);
#if ($cmd && ($cmd eq 'log' || $cmd eq 'blame')) {
#        Getopt::Long::Configure('pass_through');
#}
@ARGV=$cmds->ARGV;
my $rv = GetOptions(%opts, 'h|H' => \$_help, 'version|V' => \$_version);
exit 1 if (!$rv && $cmd);

usage(0) if $_help;
version() if $_version;
usage(1) unless defined $cmd;
usage(1) unless !$cmd->has_subcmds;

#Git::SVN::init_vars();
eval {
    #Git::SVN::verify_remotes_sanity();
    $cmd->run(@ARGV);
    #post_fetch_checkout();
};
fatal $@ if $@;
exit 0;

####################### primary functions ######################
sub usage {
    my $exit = shift || 0;
    my $fd = $exit ? \*STDERR : \*STDOUT;
    print $fd <<"";
git-labbook - manage a labbook with git
usage: git labbook <command> [subcommand] [options] [arguments]\n

    print $fd "Available commands:\n" unless $cmd;
    
    foreach (sort { $a->fullname cmp $b->fullname } $cmds->all_cmds) {
	next if $cmd && $cmd ne $_;
	#next if $_->has_subcmds && !defined($cmd);
	print $fd '  ',pack('A17',$_->displayname),$_->desc,"\n";
	foreach (sort keys %{$_->opts}) {
	    # mixed-case options are for .git/config only
	    next if /[A-Z]/ && /^[a-z]+$/i;
	    # prints out arguments as they should be passed:
	    my $x = s#[:=]s$## ? '<arg>' : s#[:=]i$## ? '<num>' : '';
	    print $fd ' ' x 21, join(', ', map { length $_ > 1 ?
						     "--$_" : "-$_" }
				     split /\|/,$_)," $x\n";
	}
    }
    exit $exit;
}

sub version {
        print "git-labbook version $VERSION\n";
        exit 0;
}

sub cmd_init {
    ensure_clean("Cannot initialize a LabBook with a dirty index");
    my $srcdir=$labbook->srcdir;
    my $datadir=$labbook->datadir;
    my $analysisdir=$labbook->analysisdir;
    $srcdir->mkpath;
    $datadir->mkpath;
    $analysisdir->mkpath;
    my $labbookfile=$labbook->labbookfile;
    if (! $labbookfile->stat()) {
	my $fh=$labbookfile->openw;
	print $fh "* Documentation\n";
	print $fh "* Experiments\n";
	$fh->close();
	command_noisy(qw/add/, $labbookfile);
	command_noisy(qw/commit -m/, "labbook initialized");
    }
    command_noisy('branch', $labbook->databranch);
    
}

sub cmd_xp_start {
    my $cmd = shift;
    my $name = shift;

    if (not defined($name)) {
	usage(1);
    }

    ensure_clean("Cannot start a new experiment with a dirty index");
    command_noisy('checkout', '-b', "xp_".$name);
    my $datadir=dir($labbook->datadir, $name);
    $datadir->mkpath;
    my $labbookfile = $labbook->labbookfile;
    my $fh=$labbookfile->opena;
    print $fh "** $name\n";
    $fh->close();
    command_noisy(qw/add/, $labbookfile);
    command_noisy(qw/commit -m/, "Experiment $name started");
}

########################### utility functions #########################

use Data::Dumper;
# convert GetOpt::Long specs for use by git-config
sub read_git_config {
    my $opts = shift;
    my @config_only;
    #print "opts=", Dumper($opts), "\n";
    chomp(my $bare = `git config --bool --get core.bare`);
    my $labbookconfig="--file .gitlabbook";
    if ($bare eq 'true') {
	$labbookconfig="--blob HEAD:.gitlabbook";
    }
    foreach my $o (keys %$opts) {
	# if we have mixedCase and a long option-only, then
	# it's a config-only variable that we don't need for
	# the command-line.
	push @config_only, $o if ($o =~ /[A-Z]/ && $o =~ /^[a-z]+$/i);
	my $v = $opts->{$o};
	my ($key) = ($o =~ /^([a-zA-Z\-]+)/);
	#$key =~ s/-//g;
	my $arg = 'git config';
	$arg .= ' --int' if ($o =~ /[:=]i$/);
	$arg .= ' --bool' if ($o !~ /[:=][sfi]$/);
	#print "v1=", Dumper($v), "\n";
	if (ref $v eq 'ARRAY') {
	    chomp(my @tmp = `$arg --get-all labbook.$key`);
	    @$v = @tmp if @tmp;
	} else {
	    chomp(my $tmp = `$arg --get labbook.$key`);
	    if (!$tmp) {
		chomp($tmp = `$arg $labbookconfig --get labbook.$key`);
	    }
	    #print "tmp=", Dumper($tmp), "\n";
	    if ($tmp && !($arg =~ / --bool/ && $tmp eq 'false')) {
		$v->($key, $tmp);
	    }
	}
	#print "v2=", Dumper($v), "\n";
    }
    delete @$opts{@config_only} if @config_only;
    #print "opts=", Dumper($opts), "\n";
}

sub ensure_clean {
    my $msg = shift;
    
    command_noisy(qw/update-index --refresh/);
    git_cmd_try { command_oneline(qw/diff-index --quiet HEAD --/) }
    $msg."\nCommit your changes first, "
	. "or stash them with `git stash'.\n";
}
    
